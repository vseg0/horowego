# make cmd example
# make --version
# make
# make clean
# `-s' и `--silent'
# `-n' или `--just-print', происходит только лишь отображение команд, без их реального выполнения.
# `-j' и `--jobs'  - parallel
# `-i' или `--ignore-errors', ignore error in all cmds

# http://rus-linux.net/nlib.php?name=/MyLDP/algol/gnu_make/gnu_make_3-79_russian_manual.html


# make -f makefileexample.mk ( or --f)
# include or MAKEFILES(envar)

#цель ... : пререквизит ...
#        команда
#        ...
#        ...

##########################
#Присваивание значения переменным


#Определения переменных обрабатываются следующим образом:

#немедленно = отложенно
#немедленно ?= отложенно
#немедленно := немедленно
#немедленно += отложенно или немедленно
#define немедленно
#  отложенно
#endef

# variables
# = рекурсивно вычисляемые (recursively expanded) переменные. (вычисление)
# := Упрощенно вычисляемые (simply expanded) переменные определяются с помощью(для переопределения)
# ?= - if not defined.

# ссылка с присваиванием-заменой
# foo := a.o b.o c.o
# bar := $(foo:.o=.c)

# VPATH = src:../headers    list of dirs for prerekvizitov separated by :   (foo.o : foo.c   ->   foo.o : src/foo.c)
# or
# vpath %.h ../headers

# ifdef, ifeq, ifndef и ifneq

# wildcard characters: `*', `?' и `[...]'
# $(wildcard *.c)
# $(patsubst %.c,%.o,$(wildcard *.c)) - превратить список исходных файлов в список объектных файлов

# $@ - target name (for command)
# $^ - list of prerekv
# $< - first prerekv (cc -c $(CFLAGS) $< -o $@ e.g. to disable passing headers)
# $* - parse target substring in name (e.g. to get big or little:     bigoutput littleoutput : %output : text.g   generate text.g -$* > $@ )

# .PHONY - abstract target
# .SUFFIXES - list of extensions of files that would be used in search of suffix rules
# .DEFAULT - cmds defined for target .DEFAULT, will be used with all targets, that does not have rules.
# .PRECIOUS - targets defined in section has special processing(e.g. targets will not be removed on update interruption)
# .INTERMEDIATE - defined prerekvezits are temp files
# .SECONDARY - targets in the list are temp files and not removed automatically
# .DELETE_ON_ERROR - targets will be removed on error/interruption
# .IGNORE - ignore errors on cmd execution for list of targets
# .SILENT - silent cmd execution for list of targets
# .EXPORT_ALL_VARIABLES - export vars for child process
# .NOTPARALLEL - not parallel execution for all.

# $(filter %.elc,$(files)): %.elc: %.el - disable target *.elc in files

# sources = foo.c bar.c
# include $(sources:.c=.d)

# Если строка, содержащая команду, начинается с символа `@', печать этой команды не производится. (@echo About to make distribution files)

# to disable error output in case of error (use - in cmd)
# clean:
#        -rm -f *.o

# override - redifine or add value from cmd line

# $(dir src/foo.c hacks)  ->  `src/ ./'.
# $(notdir src/foo.c hacks)  ->  `foo.c hacks'.
# $(suffix src/foo.c src-1.0/bar.c hacks)  ->  `.c .c'
# $(basename src/foo.c src-1.0/bar hacks)  ->  `src/foo src-1.0/bar hacks'
# $(addsuffix .c,foo bar)  ->  `foo.c bar.c'
# $(addprefix src/,foo bar)  ->  `src/foo src/bar'
# `$(join a b,.c .o)'  ->  `a.c b.o'

# dirs := a b c d
# files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
# or 
# files := $(wildcard a/* b/* c/* d/*)



# Вот перечень директив, распознаваемых GNU make:

# define имя_переменной
# endef
# Определить многострочную, рекурсивно-вычисляемую переменную.

# ifdef переменная
# ifndef переменная
# ifeq (a,b)
# ifeq "a" "b"
# ifeq 'a' 'b'
# ifneq (a,b)
# ifneq "a" "b"
# ifneq 'a' 'b'
# else
# endif
# Условно обработать часть make-файла.
# Смотрите раздел Условные части make-файла.
# include файл
# -include файл
# sinclude файл
# Подключить другой make-файл.
# Смотрите раздел Подключение других make-файлов.
# override имя_переменной = значение
# override имя_переменной := значение
# override имя_переменной += значение
# override имя_переменной ?= значение
# override define имя_переменной
# endef
# Определить переменную с "перекрытием" предыдущего ее определения (в том числе и заданного с помощью командной строки). 
# Смотрите раздел Директива override.
# export
# Инструктирует make экспортировать, по умолчанию, все переменные в дочерние процессы. 
# Смотрите раздел Связь с make "нижнего уровня" через переменные.
# export переменная
# export переменная = значение
# export переменная := значение
# export переменная += значение
# export переменная ?= значение
# unexport переменная
# Включить или отключить экспорт конкретной переменной в дочерние процессы. 
# Смотрите раздел Связь с make "нижнего уровня" через переменные
# vpath шаблон путь
# Задать путь поиска для файлов, подходящих под указанный шаблон (с символом %). 
# Смотрите раздел Директива vpath.
# vpath шаблон
# Удалить все пути поиска, заданные ранее для указанного шаблона.
# vpath
# Удалить все пути поиска, заданные ранее с помощью директив vpath.
# Далее приведен список функций, манипулирующих с текстом (смотрите раздел Функции преобразования текста):

# $(subst исходная_строка,конечная_строка,текст)
# Заменить исходную_строку на конечную_строку в указанном тексте.
# Смотрите раздел Функции анализа и подстановки строк.
# $(patsubst шаблон,замена,текст)
# Заменить все слова, подходящие под шаблон, на замену в указанном тексте.
# Смотрите раздел Функции анализа и подстановки строк.
# $(strip строка)
# Удалить из указанной строки избыточные пробелы.
# Смотрите раздел Функции анализа и подстановки строк.
# $(findstring искомая_строка,текст)
# Найти искомую_строку в указанном тексте.
# Смотрите раздел Функции анализа и подстановки строк.
# $(filter шаблон...,текст)
# Выбрать из указанного текста все слова, подходящие под шаблон(ы).
# Смотрите раздел Функции анализа и подстановки строк.
# $(filter-out шаблон...,текст)
# Выбрать из текста слова, не подходящие ни под один из указанных шаблонов.
# Смотрите раздел Функции анализа и подстановки строк.
# $(sort список)
# Отсортировать слова из списка в лексикографическом порядке, удалив дубликаты.
# Смотрите раздел Функции анализа и подстановки строк.
# $(dir имена...)
# Из указанных имен файлов выделяет части, определяющие имена каталогов.
# Смотрите раздел Функции для обработки имен файлов.
# $(notdir имена...)
# Из каждого указанного имени файла выделить часть, которая не является именем каталога.
# Смотрите раздел Функции для обработки имен файлов.
# $(suffix имена...)
# Из каждого имени файла выделить суффикс (последний `.' и следующие за ним символы).
# Смотрите раздел Функции для обработки имен файлов.
# $(basename имена...)
# Выделяет "базовое имя" (часть имени без суффикса) из каждого имени файла.
# Смотрите раздел Функции для обработки имен файлов.
# $(addsuffix суффикс,имена...)
# Добавляет суффикс к каждому из указанных имен.
# Смотрите раздел Функции для обработки имен файлов.
# $(addprefix префикс,имена...)
# Предваряет префиксом каждое из указанных имен.
# Смотрите раздел Функции для обработки имен файлов.
# $(join список1,список2)
# Объединяет два "параллельных" списка слов.
# Смотрите раздел Функции для обработки имен файлов.
# $(word n,текст)
# Выделяет n-ное слово (счет начинается с единицы) из указанного текста.
# Смотрите раздел Функции для обработки имен файлов.
# $(words текст)
# Подсчитывает количество слов в указанном тексте.
# Смотрите раздел Функции для обработки имен файлов.
# $(wordlist от,до,текст)
# Возвращает список слов из указанного текста с номерами от и до.
# Смотрите раздел Функции для обработки имен файлов.
# $(firstword имена...)
# Выделяет первое слово из указанного списка имен.
# Смотрите раздел Функции для обработки имен файлов.
# $(wildcard шаблон...)
# Получить список файлов, чьи имена подходят под указанный шаблон (шаблон записывает в формате интерпретатора командной строки, а не `%'-шаблона).
# Смотрите раздел Функция wildcard.
# $(error сообщение...)
# При вычислении этой функции, make генерирует фатальную ошибку с указанным сообщением.
# Смотрите раздел Функции управления сборкой.
# $(warning сообщение...)
# При вычислении этой функции, make выдает предупреждение (warning) с указанным сообщением.
# Смотрите раздел Функции управления сборкой.
# $(shell команда)
# Выполнить команду оболочки и возвратить выведенную ей информацию. 
# Смотрите раздел Функция shell.
# $(origin переменная)
# Вернуть строку, описывающую, каким образом была определена переменная make переменная.
# Смотрите раздел Функция origin.
# $(foreach переменная-аргумент,слова,текст)
# Вычислить значение текста, поочередно подставляя в переменную-аргумент слова из списка слова, и объединить полученные результаты.
# Смотрите раздел Функция foreach.
# $(call переменная,параметр,...)
# Вычислить и вернуть значение переменной, заменяя ссылки $(1), $(2) на значения первого, второго и так далее параметров.
# Смотрите раздел Функция call.
# Вот список имеющихся автоматических переменных. Смотрите раздел Автоматические переменные, где они описаны подробно.

# $@ - Имя файла цели.
# $% - Имя элемента для целей, являющихся элементами архива.
# $< - Имя первого пререквизита из списка пререквизитов
# $? - Имена всех пререквизитов (разделенные пробелами), которые являются более новыми, чем цель. Для пререквизитов, являющихся элементами архивов, используются только имена элементов (смотрите раздел Использование make для обновления архивов).
# $^
# $+ - Имена всех пререквизитов, разделенные пробелами. Для пререквизитов, являющихся элементами архивов, используются только имена элементов (смотрите раздел Использование make для обновления архивов). Значение переменной $^ не содержит дубликатов пререквизитов, в то время как $+ сохраняет дубликаты и "оригинальный" порядок следования пререквизитов.
# $* - Основа имени (stem), с которой было сопоставлено неявное правило (смотрите раздел Процедура сопоставления с шаблоном).
# $(@D)
# $(@F) - Части имени $@, которые представляют собой имя каталога и имя файла внутри каталога, соответственно.
# $(*D)
# $(*F) - Части имени $*, которые представляют собой имя каталога и имя файла внутри каталога, соответственно.
# $(%D)
# $(%F) - Части имени $%, которые представляют собой имя каталога и имя файла внутри каталога, соответственно.
# $(<D)
# $(<F) - Части имени $<, которые представляют собой имя каталога и имя файла внутри каталога, соответственно.
# $(^D)
# $(^F) - Части имени $^, которые представляют собой имя каталога и имя файла внутри каталога, соответственно.
# $(+D)
# $(+F) - Части имени $+, которые представляют собой имя каталога и имя файла внутри каталога, соответственно.
# $(?D)
# $(?F) - Части имени $?, которые представляют собой имя каталога и имя файла внутри каталога, соответственно.

# MAKEFILES - Make-файлы, которые будут считываться при каждом вызове make.
# VPATH - Путь поиска для файлов, которые не могут быть найдены в текущем каталоге.
# SHELL - Имя используемого по умолчанию командного интерпретатора, обычно `/bin/sh'. В своем make-файле вы можете установить для переменной SHELL новое значение, изменив, тем самым, командный интерпретатор, который будет использоваться для вызова команд. Смотрите раздел Исполнение команд.
# MAKESHELL - Используется только при работе в системе MS-DOS и содержит имя командного интерпретатора, который будет использоваться make. Это значение имеет приоритет перед значением переменной SHELL. Смотрите раздел Исполнение команд.
# MAKE - Имя, с помощью которого была вызвана make. Использование этой переменной в командах имеет специальное значение. Смотрите раздел Как работает переменная MAKE.
# MAKELEVEL - Текущий "уровень вложенности" make при рекурсивном вызове.
# MAKEFLAGS Опции, заданные для make. Вы можете установить эту переменную из операционной среды или присвоить ей нужное значение внутри make-файла.
# MAKECMDGOALS - Цели, заданные make в командной строке. Присваивание этой переменной другого значения не влияет на работу make.
# CURDIR - Имя текущего рабочего каталога (после того, как были обработаны все опции -C, если такие были заданы). Присваивание этой переменной другого значения, не влияет на работу make.
# SUFFIXES - Список используемых по умолчанию (до того, как make начнет интерпретировать make-файлы) суффиксов для суффиксных правил.
# .LIBPATTERNS - Определяет способ именования и порядок следования библиотек, поиск которых проводит make.



##### Version 1. #####
#objects = main.o ut_logger.o \
#          ut_module_1.o

#myprogram : $(objects)
#        cc -o myprogram $(objects)
		
#main.o : main.c ut_const.h
#        cc -c main.c
		
#ut_logger.o : ut_logger.c ut_const.h ut_logger.h
#        cc -c ut_logger.c
		
#ut_module_1.o : ut_module_1.c ut_const.h ut_module_1.h
#        cc -c ut_module_1.c

#.PHONY : clean
#clean :
#        rm myprogram $(objects)
		
#неявное правило (implicit rule) для обновления файлов с расширением `.o' из файлов с расширеним `.c', с помощью команды `cc -c'. Например, она бы использовала команду `cc -c main.c -o main.o' для преобразования файла `main.c' в файл `main.o'. Таким образом, можно убрать явное указание команд компиляции из правил, описывающих построение объектных файлов.
#можем убрать файлы с расширением `.c' из списков пререквизитов объектных файлов.

##### Version 2. #####
objects = main.o ut_logger.o \
          ut_module_1.o

myprogram : $(objects)
        cc -o myprogram $(objects)
		
main.o : ut_const.h
ut_logger.o : ut_const.h ut_logger.h
ut_module_1.o : ut_const.h ut_module_1.h

.PHONY : clean
clean :
        rm myprogram $(objects)
		